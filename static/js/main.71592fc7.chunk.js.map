{"version":3,"sources":["components/Marker.jsx","containers/CommandLine.jsx","utils/parseCommand.js","utils/getListStr.js","utils/storageManager.js","utils/typeCheck.js","containers/CommandsController.jsx","App.js","reportWebVitals.js","index.js"],"names":["Marker","CommandLine","props","useState","commandStr","setCommandStr","readOnly","setReadOnly","className","type","value","onChange","event","target","onKeyDown","key","preventDefault","onCommandSubmit","setExpireParser","command","strArray","slice","length","join","replace","parseCommand","str","strArr","split","valArr","match","values","i","push","map","el","saddParser","getParser","keys","delExsitsSinterParser","getListStr","list","listArr","exists","numKeysEx","forEach","localStorage","getItem","del","numKeysDel","removeItem","sadd","val","numElAdd","storedVal","JSON","parse","arr","toStore","expire","setItem","stringify","Array","isArray","Error","includes","newStoredVal","updateStorage","set","now","Date","getTime","data","result","reduce","a","b","filter","c","sinter","get","err","message","CommandsController","commandsList","setList","responsesList","setResponsesList","handleCommandSubmit","commandsListCopy","parsedCommand","responseStr","responsesListCopy","index","renderCommandsItem","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.71592fc7.chunk.js","sourcesContent":["const Marker = () => `>>`;\n\nexport default Marker;\n","import React, { useState } from \"react\";\nimport \"./CommandLine.css\";\nimport Marker from \"../components/Marker\";\n\nconst CommandLine = (props) => {\n  const [commandStr, setCommandStr] = useState(\"\");\n  const [readOnly, setReadOnly] = useState(false);\n\n  const handleKeyDown = (event) => {\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n      props.onCommandSubmit(commandStr);\n      setReadOnly(true);\n    }\n  };\n\n  const handleChange = (event) => {\n    setCommandStr(event.target.value);\n  };\n\n  return (\n    <div className=\"commandLine\">\n      <Marker />\n      <input\n        type=\"text\"\n        className=\"userInput\"\n        value={commandStr}\n        onChange={handleChange}\n        onKeyDown={handleKeyDown}\n        readOnly={readOnly}\n      />\n    </div>\n  );\n};\n\nexport default CommandLine;\n","const setExpireParser = (command, strArray) => {\n  const key = strArray[1];\n  const value = `${strArray.slice(2, strArray.length).join(\" \")}`;\n  return { command, key, value: value.replace(/['\"]+/g, \"\") };\n};\n\nconst saddParser = (command, strArray) => {\n  const key = strArray[1];\n  const value = `${strArray.slice(2, strArray.length).join(\" \")}`;\n  const pattern = /\".*?\"/g;\n  const valArr = value.match(pattern);\n  const values = [];\n  for (let i = 0; i < valArr.length; i += 1) {\n    values.push(valArr[i]);\n  }\n  return { command, key, values: values.map((el) => el.replace(/['\"]+/g, \"\")) };\n};\n\nconst getParser = (command, strArray) => {\n  const key = strArray[1];\n  return { command, key };\n};\n\nconst delExsitsSinterParser = (command, strArray) => {\n  const keys = [];\n  for (let i = 1; i < strArray.length; i += 1) {\n    keys.push(strArray[i]);\n  }\n  return { command, keys };\n};\n\nconst parseCommand = (str) => {\n  const strArr = str.split(\" \");\n  const command = strArr[0];\n\n  switch (command) {\n    case \"SET\":\n      return setExpireParser(command, strArr);\n    case \"EXPIRE\":\n      return setExpireParser(command, strArr);\n    case \"SADD\":\n      return saddParser(command, strArr);\n    case \"GET\":\n      return getParser(command, strArr);\n    default:\n      //DEL, EXISTS, SINTER\n      //KEYS - missing implementation\n      return delExsitsSinterParser(command, strArr);\n  }\n};\n\nexport default parseCommand;\n","const getListStr = (list) => {\n  const listArr = [];\n\n  if (!list.length) return `(empty list or set)`;\n\n  for (let i = 0; i < list.length; i += 1) {\n    listArr.push(`${i + 1}) ${list[i]}`);\n  }\n\n  return listArr.join(\"\\n\");\n};\n\nexport default getListStr;\n","import getListStr from \"./getListStr\";\nimport { isSet, isString } from \"./typeCheck\";\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* SET function by the following rules: https://redis.io/commands/set */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst set = (key, value) => {\n  const toStore = { value, expire: null };\n  localStorage.setItem(key, JSON.stringify(toStore));\n  return '\"OK\"';\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* GET function by the following rules: https://redis.io/commands/get */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst get = (key) => {\n  const storedVal = JSON.parse(localStorage.getItem(`${key}`));\n\n  if (storedVal) {\n    // If value stored is not a string throw an error.\n    if (!isString(storedVal.value)) {\n      throw new Error(\n        `value stored at ${key} is not a string. GET only handles string values.\\nPlease try again.`\n      );\n    }\n\n    // Return value of key if key exist\n    if (storedVal.value) {\n      return `\"${storedVal.value}\"`;\n    }\n  }\n\n  // If key does not exist, return nil\n  return \"(nil)\";\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* EXISTS function by the following rules: https://redis.io/commands/exists */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst exists = (keys) => {\n  let numKeysEx = 0;\n\n  keys.forEach((key) => {\n    const value = localStorage.getItem(`${key}`);\n    if (value) {\n      numKeysEx += 1;\n    }\n  });\n\n  // If key does not exist, return 0\n  if (!numKeysEx) {\n    return \"(integer) 0\";\n  }\n\n  // Return number of keys existing among the specified ones.\n  // Keys mentioned multiple times and existing are counted multiple times.\n  return `(integer) ${numKeysEx}`;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* DEL function by the following rules: https://redis.io/commands/del */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst del = (keys) => {\n  let numKeysDel = 0;\n\n  // For each key user wish to delete\n  keys.forEach((key) => {\n    // If the key exists, remove it.\n    // Otherwise, ignore it.\n    if (exists([key]) === \"(integer) 1\") {\n      localStorage.removeItem(`${key}`);\n      numKeysDel += 1;\n    }\n  });\n\n  // Return number of keys that were removed.\n  return `(integer) ${numKeysDel}`;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* EXPIRE function by the following rules: https://redis.io/commands/expire */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst expire = (key, value) => {\n  const storedVal = JSON.parse(localStorage.getItem(`${key}`));\n  const now = new Date();\n\n  // If value is non positive, the key will be delted.\n  if (value <= 0) return del([key]);\n\n  // If there was no expiry time on key, set expiry time.\n  // If there was an expiry time that is no later than now, set expiry time.\n  if (storedVal.expire === null || now.getTime() < storedVal.expire) {\n    storedVal.expire = now.getTime() + value * 1000;\n    localStorage.setItem(key, JSON.stringify(storedVal));\n    return \"(integer) 1\";\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* SADD function by the following rules: https://redis.io/commands/sadd */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst sadd = (key, values) => {\n  let numElAdd = 0;\n\n  const storedVal = JSON.parse(localStorage.getItem(`${key}`));\n  const arr = storedVal ? storedVal.value.slice() : [];\n\n  // If key does not exist, a new set is created *before* adding the specified members.\n  if (exists([key]) !== \"(integer) 1\") {\n    const toStore = { value: values.slice(), expire: null };\n    localStorage.setItem(key, JSON.stringify(toStore));\n  }\n\n  // If value stored is not a set throw an error.\n  if (!isSet(arr)) {\n    throw new Error(\n      `value stored at ${key} is not a set. SADD only handles array values.\\nPlease try again.`\n    );\n  }\n\n  for (let i = 0; i < values.length; i += 1) {\n    // If the member is not in the set, add it.\n    // Otherwise, ignore it.\n    if (!arr.includes(values[i])) {\n      arr.push(values[i]);\n      numElAdd++;\n    }\n  }\n\n  const newStoredVal = JSON.parse(localStorage.getItem(`${key}`));\n  localStorage.setItem(\n    `${key}`,\n    JSON.stringify({ ...newStoredVal, value: arr })\n  );\n\n  // Return number of keys that were added to the set.\n  return `(integer) ${numElAdd}`;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/* SINTER function by the following rules: https://redis.io/commands/sinter */\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst sinter = (keys) => {\n  const data = [];\n\n  for (let i = 0; i < keys.length; i += 1) {\n    data[i] = JSON.parse(localStorage.getItem(`${keys[i]}`)).value;\n  }\n\n  // Finding intersection members\n  const result = data.reduce((a, b) => a.filter((c) => b.includes(c)));\n\n  // Return the members of the set resulting from the intersection,\n  // If the result it empty set, empty string will be returned.\n  return `${getListStr(result)}`;\n};\n\n// const keys= (keys) => {}\n\nexport const updateStorage = (command) => {\n  try {\n    switch (command.command) {\n      case \"SET\":\n        return set(command.key, command.value);\n      case \"DEL\":\n        return del(command.keys);\n      case \"EXISTS\":\n        return exists(command.keys);\n      case \"EXPIRE\":\n        return expire(command.key, command.value);\n      case \"SADD\":\n        return sadd(command.key, command.values);\n      case \"SINTER\":\n        return sinter(command.keys);\n      // case \"KEYS\":\n      // return keys(command.keys);\n      default:\n        return get(command.key);\n    }\n  } catch (err) {\n    return err.message;\n  }\n};\n","export const isString = (val) => typeof val === \"string\";\n\nexport const isSet = (val) => Array.isArray(val);\n","import React, { useState } from \"react\";\nimport \"./CommandsController.css\";\nimport CommandLine from \"./CommandLine\";\nimport parseCommand from \"../utils/parseCommand\";\nimport { updateStorage } from \"../utils/storageManager\";\n\nconst CommandsController = () => {\n  const [commandsList, setList] = useState([]);\n  const [responsesList, setResponsesList] = useState([]);\n\n  const handleCommandSubmit = (commandStr) => {\n    const commandsListCopy = commandsList.slice();\n    commandsListCopy.push(commandStr);\n    setList(commandsListCopy);\n    const parsedCommand = parseCommand(commandStr);\n    const responseStr = updateStorage(parsedCommand);\n    const responsesListCopy = responsesList.slice();\n    responsesListCopy.push(responseStr);\n    setResponsesList(responsesListCopy);\n  };\n\n  const renderCommandsItem = (el, index) => (\n    <li key={index}>\n      <div className=\"responseLine\">\n        {responsesList[index] ? responsesList[index] : null}\n      </div>\n      <CommandLine onCommandSubmit={handleCommandSubmit} />\n    </li>\n  );\n\n  return (\n    <>\n      <CommandLine onCommandSubmit={handleCommandSubmit} />\n      <ul className=\"CommandsHistory\">\n        {commandsList.map((el, index) => renderCommandsItem(el, index))}\n      </ul>\n    </>\n  );\n};\n\nexport default CommandsController;\n","import React from \"react\";\nimport \"./App.css\";\nimport CommandsController from \"./containers/CommandsController\";\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <CommandsController />\n    </div>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}